<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escape Game Test</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            padding: 40px 20px;
        }

        #gameCanvas {
            width: 100%;
            height: auto;
            min-width: 400px;
            min-height: 300px;
            max-width: 800px;
            max-height: 600px;
        }
    </style>

</head>

<body>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>

        'use strict';
        console.group('Brick Breaker Load');
        console.group('Game Compilation');
        console.log('compilation started...');

        let canvas;
        let canvastContext;

        let ball = {
            x: {
                pos: 75,
                speed: 5
            },
            y: {
                pos: 75,
                speed: 7
            }
        };

        let paddle = {
            width: 100,
            height: 10,
            pos: {
                x: 400,
                y: 100
            }
        };

        const PADDLE_THICKNESS = paddle.height;
        const PADDLE_WIDTH = paddle.width;
        const PADDLE_TOP = PADDLE_THICKNESS * 5;

        let mouse = {
            x: 0,
            y: 0
        }

        let layout1 = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1
        ];

        let layout2 = [
            1, 1, 1, 1, 0, 1, 1, 1,
            1, 1, 0, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 0, 1,
            1, 1, 1, 1, 1, 1, 1, 1,
            1, 0, 0, 0, 0, 1, 0, 1
        ];

        let levelInfo = {
            level1: {
                brick: {
                    width: 80,
                    height: 20,
                    gap: 2,
                    gutter: 3,
                    layout: [...layout1]
                }
            },
            level2: {
                brick: {
                    width: 100,
                    height: 20,
                    gap: 2,
                    layout: layout2
                }
            }
        }

        let currentLevel = 'level1';
        let currentLevelInfo = levelInfo[currentLevel];

        let bricksLeft = 0;
        let bricksCounted = false;

        let myInterval;

        window.onload = function () {
            console.group('Set Game Parameters');
            console.log('setting game parameters...');
            canvas = document.querySelector('#gameCanvas');
            canvastContext = canvas.getContext('2d');

            console.log('game parameters set');
            console.groupEnd();
            init();
        };


        /*****************************
         * ADD YOUR CUSTOM CODE HERE *
        ******************************/
        function updateScreen() {
            drawObjects();
            objectCollisions();
            movingObjects();

            // TODO: START: mouse coords debug lines
            let brickCol = Math.floor(mouse.x / currentLevelInfo.brick.width);
            let brickRow = Math.floor(mouse.y / currentLevelInfo.brick.height);

            // let brickUnderMouse = getRowColLayoutIndex(brickCol, brickRow);
            // drawText(`${brickCol},${brickRow}:${brickUnderMouse}`, mouse.x, mouse.y, 'yellow');

            // if (brickCol >= 0 && brickCol < getColCount() &&
            //     brickRow >= 0 && brickRow < getRowCount()) {
            //     currentLevelInfo.brick.layout[brickUnderMouse] = 0;
            // }
            // TODO: END: mouse coords debug lines
        }

        function drawObjects() {
            drawCanvas();
            drawBall();
            drawPaddle();
            drawBricks();
        }

        function objectCollisions() {
            paddleCollision();
            brickCollision();
        }

        function movingObjects() {
            moveBall();
        }


        /********************************
         * START: BASE ENGINE FUNCTIONS *
        *********************************/

        function init() {
            console.log('Game build sucessful.');
            console.groupEnd();
            console.log('Game Menu.');

            addEventListeners();
            ballReset();
            bricksCounted = false;
            handleInterval();
        }

        function handleInterval() {
            let framesPerSecond = 30;
            myInterval = setInterval(updateScreen, 1000 / framesPerSecond);
        }

        function addEventListeners() {
            canvas.addEventListener('mousemove', updateMousePos);
        }

        function updateMousePos(e) {
            let rect = canvas.getBoundingClientRect();
            let root = document.documentElement;

            mouse.x = e.clientX - rect.left - root.scrollLeft;
            mouse.y = e.clientY - rect.top - root.scrollTop;

            paddle.pos.x = mouse.x - (PADDLE_WIDTH / 2);

            // TODO: temp mod for testing
            // ball.x.pos = mouse.x;
            // ball.y.pos = mouse.y;
            // ball.x.speed = 4;
            // ball.y.speed = -4;
        }

        // TODO: update to use layout/map vs canvas width
        function getRowCount() {
            return (currentLevelInfo.brick.layout.length * currentLevelInfo.brick.width) / canvas.width;
        }

        // TODO: update to use layout/map vs canvas width
        function getColCount() {
            return currentLevelInfo.brick.layout.length / getRowCount();
        }

        function getRowColLayoutIndex(col, row) {
            return col + getColCount() * row;
        }

        function drawCanvas() {
            let canvasBackground = 'black';
            drawRect(0, 0, canvas.width, canvas.height, canvasBackground);
        }

        function drawRect(topLeftX, topLeftY, width, height, fillColor) {
            canvastContext.fillStyle = fillColor;
            canvastContext.fillRect(topLeftX, topLeftY, width, height);
        }

        function drawCircle(centerX, centerY, radius, fillColor) {
            canvastContext.fillStyle = fillColor;
            canvastContext.beginPath();
            canvastContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
            canvastContext.fill();
        }

        function drawText(text, xPos, yPos, color) {
            canvastContext.fillStyle = color;
            canvastContext.fillText(text, xPos, yPos);
        }

        /******************************
         * END: BASE ENGINE FUNCTIONS *
        *******************************/


        /*****************************
         * START: GAME SPECIFIC CODE *
        ******************************/

        function drawBall() {
            let ballBackground = 'red';
            drawCircle(ball.x.pos, ball.y.pos, 10, ballBackground);
        }

        function ballReset() {
            console.log("game over");
            ball.x.pos = paddle.pos.x;
            ball.y.pos = paddle.pos.y;
        }

        function gameOver() {
            clearInterval(myInterval);
            currentLevelInfo.brick.layout = [...layout1];
            init();
        }

        function moveBall() {
            ball.x.pos += ball.x.speed;
            ball.y.pos += ball.y.speed;

            setBallBoundries();
        }

        function ballReset() {
            ball.x.pos = canvas.width / 2;
            ball.y.pos = canvas.height / 2;
        }

        function setBallBoundries() {
            // set left
            if (ball.x.pos < 0 && ball.x.speed < 0.0) {
                ball.x.speed *= -1;
            }
            // set right
            if (ball.x.pos > canvas.width && ball.x.speed > 0.0) {
                ball.x.speed *= -1;
            }
            // set top
            if (ball.y.pos < 0 && ball.y.speed < 0.0) {
                ball.y.speed *= -1;
            }
            // set bottom
            if (ball.y.pos > canvas.height) {
                ballReset();
            }
        }

        function drawPaddle() {
            let paddleBackground = 'white';
            drawRect(paddle.pos.x,
                canvas.height - PADDLE_TOP,
                PADDLE_WIDTH,
                PADDLE_THICKNESS,
                paddleBackground
            );
        }

        function paddleCollision() {
            let topOfPaddle = canvas.height - PADDLE_TOP;
            if (ball.y.pos > topOfPaddle &&
                ball.y.pos < topOfPaddle + PADDLE_THICKNESS &&
                ball.x.pos > paddle.pos.x &&
                ball.x.pos < paddle.pos.x + PADDLE_WIDTH) {
                ball.y.speed *= -1;

                let centerOfPaddle = paddle.pos.x + (PADDLE_WIDTH / 2);
                let ballDistFromPaddleCenter = ball.x.pos - centerOfPaddle;
                ball.x.speed = ballDistFromPaddleCenter * 0.35;

                if (bricksLeft === 0) {
                    gameOver();
                }
            }
        }

        function drawBricks() {
            let brickBackground = ['blue', 'purple', 'green', 'red'];
            let brick = currentLevelInfo.brick;

            for (let row = 0; row < getRowCount(); row++) {
                for (let col = 0; col < getColCount(); col++) {
                    let brickNumber = getRowColLayoutIndex(col, row);
                    if (brick.layout[brickNumber] === 1) {
                        drawRect(brick.width * col, brick.height * row, brick.width - brick.gap, brick.height - brick.gap, brickBackground[row - brick.gutter]);
                        if (!bricksCounted) {
                            bricksLeft++;
                        }
                    }
                }
            }
            bricksCounted = true;
        }

        function brickCollision() {
            let ballBrickCol = Math.floor(ball.x.pos / currentLevelInfo.brick.width);
            let ballBrickRow = Math.floor(ball.y.pos / currentLevelInfo.brick.height);
            let brickUnderBall = getRowColLayoutIndex(ballBrickCol, ballBrickRow);

            if (ballBrickCol >= 0 && ballBrickCol < getColCount() &&
                ballBrickRow >= 0 && ballBrickRow < getRowCount()) {
                if (currentLevelInfo.brick.layout[brickUnderBall] === 1) {
                    currentLevelInfo.brick.layout[brickUnderBall] = 0;
                    bricksLeft--;

                    let prevBallCol = ball.x.pos - ball.x.speed;
                    let prevBallRow = ball.y.pos - ball.y.speed;
                    let prevBrickCol = Math.floor(prevBallCol / currentLevelInfo.brick.width);
                    let prevBrickRow = Math.floor(prevBallRow / currentLevelInfo.brick.height);

                    let bothTestsFailed = true;
                    // check sides of brick
                    if (prevBrickCol !== ballBrickCol) {
                        if (!isBrickAtColRow(prevBrickCol, ballBrickRow)) {
                            ball.x.speed *= -1;
                            bothTestsFailed = false;
                        }
                    }
                    // check bottom/top of brick
                    if (prevBrickRow !== ballBrickRow) {
                        if (!isBrickAtColRow(ballBrickCol, prevBrickRow)) {
                            ball.y.speed *= -1;
                            bothTestsFailed = false;
                        }
                    }
                    // checks for armpit
                    if (bothTestsFailed) {
                        ball.x.speed *= -1;
                        ball.y.speed *= -1;
                    }
                }
            }
        }

        function isBrickAtColRow(col, row) {
            if (col >= 0 && col < getColCount() &&
                row >= 0 && row < getRowCount()) {
                let brickUnderCoord = getRowColLayoutIndex(col, row);
                return currentLevelInfo.brick.layout[brickUnderCoord];
            } else {
                return false;
            }
        }

        /***************************
         * END: GAME SPECIFIC CODE *
        ****************************/

        console.log('compilation finished.');
        console.groupEnd();
    </script>

</body>

</html>