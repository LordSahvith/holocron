<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Racing Game Test</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            padding: 40px 20px;
        }

        #gameCanvas {
            width: 100%;
            height: auto;
            min-width: 400px;
            min-height: 300px;
            max-width: 800px;
            max-height: 600px;
        }
    </style>

</head>

<body>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>

        'use strict';
        console.group('Track Breaker Load');
        console.group('Game Compilation');
        console.log('compilation started...');

        let carPic = document.createElement('img');
        let carPicLoaded = false;

        let canvas;
        let canvastContext;

        const KEY_W = 87;
        const KEY_A = 65;
        const KEY_S = 83;
        const KEY_D = 68;

        let keyHeld_Gas = false;
        let keyHeld_Reverse = false;
        let keyHeld_TurnLeft = false;
        let keyHeld_TurnRight = false;

        const GROUNDSPEED_FRICTION = 0.94;
        const GAS_POWER = 0.5;
        const REVERSE_POWER = 0.2;
        const TURN_RATE = 0.03;

        let car = {
            x: {
                pos: 75,
                speed: 5
            },
            y: {
                pos: 75,
                speed: 7
            },
            ang: 0,
            speed: 0
        };

        let mouse = {
            x: 0,
            y: 0
        }

        let layout1 = [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
        ];

        let layout2 = [
            1, 1, 1, 1, 0, 1, 1, 1,
            1, 1, 0, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 0, 1,
            1, 1, 1, 1, 1, 1, 1, 1,
            1, 0, 0, 0, 0, 1, 0, 1
        ];

        let levelInfo = {
            level1: {
                track: {
                    width: 40,
                    height: 40,
                    gap: 2,
                    gutter: 0,
                    layout: [...layout1]
                }
            },
            level2: {
                track: {
                    width: 100,
                    height: 20,
                    gap: 2,
                    layout: layout2
                }
            }
        }

        let currentLevel = 'level1';
        let currentLevelInfo = levelInfo[currentLevel];

        let myInterval;

        window.onload = function () {
            console.group('Set Game Parameters');
            console.log('setting game parameters...');
            canvas = document.querySelector('#gameCanvas');
            canvastContext = canvas.getContext('2d');

            carPic.onload = function () {
                carPicLoaded = true;
            };

            carPic.src = 'img/player1car.png';

            console.log('game parameters set');
            console.groupEnd();
            init();
        };


        /*****************************
         * ADD YOUR CUSTOM CODE HERE *
        ******************************/
        function updateScreen() {
            drawObjects();
            objectCollisions();
            movingObjects();

            // TODO: START: mouse coords debug lines
            let trackCol = Math.floor(mouse.x / currentLevelInfo.track.width);
            let trackRow = Math.floor(mouse.y / currentLevelInfo.track.height);

            // let trackUnderMouse = getRowColLayoutIndex(trackCol, trackRow);
            // drawText(`${trackCol},${trackRow}:${trackUnderMouse}`, mouse.x, mouse.y, 'yellow');

            // if (trackCol >= 0 && trackCol < getColCount() &&
            //     trackRow >= 0 && trackRow < getRowCount()) {
            //     currentLevelInfo.track.layout[trackUnderMouse] = 0;
            // }
            // TODO: END: mouse coords debug lines
        }

        function drawObjects() {
            drawCanvas();
            drawCar();
            drawTracks();
        }

        function objectCollisions() {
            trackCollision();
        }

        function movingObjects() {
            moveCar();
        }

        function keyPressed(e) {
            // console.log('Key Press:', e.keyCode);
            e.preventDefault();

            if (e.keyCode === KEY_A) {
                keyHeld_TurnLeft = true;
            }

            if (e.keyCode === KEY_D) {
                keyHeld_TurnRight = true;
            }

            if (e.keyCode === KEY_W) {
                keyHeld_Gas = true;
            }

            if (e.keyCode === KEY_S) {
                keyHeld_Reverse = true;
            }
        }

        function keyReleased(e) {
            // console.log('Key Release:', e.keyCode);
            e.preventDefault();

            if (e.keyCode === KEY_A) {
                keyHeld_TurnLeft = false;
            }

            if (e.keyCode === KEY_D) {
                keyHeld_TurnRight = false;
            }

            if (e.keyCode === KEY_W) {
                keyHeld_Gas = false;
            }

            if (e.keyCode === KEY_S) {
                keyHeld_Reverse = false;
            }
        }


        /********************************
         * START: BASE ENGINE FUNCTIONS *
        *********************************/

        function init() {
            console.log('Game build sucessful.');
            console.groupEnd();
            console.log('Game Menu.');

            addEventListeners();
            carReset();
            handleInterval();
        }

        function handleInterval() {
            let framesPerSecond = 30;
            myInterval = setInterval(updateScreen, 1000 / framesPerSecond);
        }

        function addEventListeners() {
            canvas.addEventListener('mousemove', updateMousePos);
            document.addEventListener('keydown', keyPressed);
            document.addEventListener('keyup', keyReleased);
        }

        function updateMousePos(e) {
            let rect = canvas.getBoundingClientRect();
            let root = document.documentElement;

            mouse.x = e.clientX - rect.left - root.scrollLeft;
            mouse.y = e.clientY - rect.top - root.scrollTop;

            // TODO: temp mod for testing
            // car.x.pos = mouse.x;
            // car.y.pos = mouse.y;
            // car.x.speed = 4;
            // car.y.speed = -4;
        }

        // TODO: update to use layout/map vs canvas width
        function getRowCount() {
            return (currentLevelInfo.track.layout.length * currentLevelInfo.track.width) / canvas.width;
        }

        // TODO: update to use layout/map vs canvas width
        function getColCount() {
            return currentLevelInfo.track.layout.length / getRowCount();
        }

        function getRowColLayoutIndex(col, row) {
            return col + getColCount() * row;
        }

        function drawCanvas() {
            let canvasBackground = 'black';
            drawRect(0, 0, canvas.width, canvas.height, canvasBackground);
        }

        function drawRect(topLeftX, topLeftY, width, height, fillColor) {
            canvastContext.fillStyle = fillColor;
            canvastContext.fillRect(topLeftX, topLeftY, width, height);
        }

        function drawCircle(centerX, centerY, radius, fillColor) {
            canvastContext.fillStyle = fillColor;
            canvastContext.beginPath();
            canvastContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
            canvastContext.fill();
        }

        function drawText(text, xPos, yPos, color) {
            canvastContext.fillStyle = color;
            canvastContext.fillText(text, xPos, yPos);
        }

        /******************************
         * END: BASE ENGINE FUNCTIONS *
        *******************************/


        /*****************************
         * START: GAME SPECIFIC CODE *
        ******************************/

        function drawCar() {
            // let carBackground = 'red';
            // drawCircle(car.x.pos, car.y.pos, 10, carBackground);
            if (carPicLoaded) {
                drawBitMapCenteredWithRotation(carPic, car.x.pos, car.y.pos, car.ang);
            }
        }

        function gameOver() {
            clearInterval(myInterval);
            currentLevelInfo.track.layout = [...layout1];
            init();
        }

        function moveCar() {
            car.speed *= GROUNDSPEED_FRICTION;

            if (keyHeld_Gas) {
                car.speed += GAS_POWER;
            }

            if (keyHeld_Reverse) {
                car.speed -= REVERSE_POWER;
            }

            if (keyHeld_TurnLeft) {
                car.ang -= TURN_RATE;
            }

            if (keyHeld_TurnRight) {
                car.ang += TURN_RATE;
            }

            car.x.pos += Math.cos(car.ang) * car.speed;
            car.y.pos += Math.sin(car.ang) * car.speed;
            setCarBoundries();
        }

        function drawBitMapCenteredWithRotation(useBitmap, atX, atY, withAng) {
            canvastContext.save();
            canvastContext.translate(atX, atY);
            canvastContext.rotate(withAng);
            canvastContext.drawImage(useBitmap, -useBitmap.width / 2, -useBitmap.height / 2);
            canvastContext.restore();
        }

        function carReset() {
            let trackBackground = 'red';
            let track = currentLevelInfo.track;

            for (let row = 0; row < getRowCount(); row++) {
                for (let col = 0; col < getColCount(); col++) {
                    let trackNumber = getRowColLayoutIndex(col, row);
                    if (track.layout[trackNumber] === 2) {
                        track.layout[trackNumber] = 0;
                        car.ang = -Math.PI / 2;
                        car.x.pos = (col * track.width) + (track.width / 2);
                        car.y.pos = (row * track.height) + (track.height / 2);
                    }
                }
            }
        }

        function setCarBoundries() {
            // set left
            if (car.x.pos < 0 && car.x.speed < 0.0) {
                car.x.speed *= -1;
            }
            // set right
            if (car.x.pos > canvas.width && car.x.speed > 0.0) {
                car.x.speed *= -1;
            }
            // set top
            if (car.y.pos < 0 && car.y.speed < 0.0) {
                car.y.speed *= -1;
            }
            // set bottom
            if (car.y.pos > canvas.height) {
                carReset();
            }
        }

        function drawTracks() {
            let trackBackground = 'red';
            let track = currentLevelInfo.track;

            for (let row = 0; row < getRowCount(); row++) {
                for (let col = 0; col < getColCount(); col++) {
                    let trackNumber = getRowColLayoutIndex(col, row);
                    if (track.layout[trackNumber] === 1) {
                        drawRect(track.width * col, track.height * row, track.width - track.gap, track.height - track.gap, trackBackground);
                    }
                }
            }
        }

        function trackCollision() {
            let carTrackCol = Math.floor(car.x.pos / currentLevelInfo.track.width);
            let carTrackRow = Math.floor(car.y.pos / currentLevelInfo.track.height);
            let trackUnderCar = getRowColLayoutIndex(carTrackCol, carTrackRow);

            if (carTrackCol >= 0 && carTrackCol < getColCount() &&
                carTrackRow >= 0 && carTrackRow < getRowCount()) {
                if (currentLevelInfo.track.layout[trackUnderCar] === 1) {
                    car.x.pos -= Math.cos(car.ang) * car.speed;
                    car.y.pos -= Math.sin(car.ang) * car.speed;
                    car.speed *= -0.5;
                }
            }
        }

        function isTrackAtColRow(col, row) {
            if (col >= 0 && col < getColCount() &&
                row >= 0 && row < getRowCount()) {
                let trackUnderCoord = getRowColLayoutIndex(col, row);
                return currentLevelInfo.track.layout[trackUnderCoord];
            } else {
                return false;
            }
        }

        /***************************
         * END: GAME SPECIFIC CODE *
        ****************************/

        console.log('compilation finished.');
        console.groupEnd();
    </script>

</body>

</html>