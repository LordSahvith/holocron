<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Racing Game Test</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            padding: 40px 20px;
        }

        #gameCanvas {
            width: 100%;
            height: auto;
            min-width: 400px;
            min-height: 300px;
            max-width: 800px;
            max-height: 600px;
        }
    </style>

</head>

<body>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>

        'use strict';
        console.group('Track Breaker Load');
        console.group('Game Compilation');
        console.log('compilation started...');

        let carPic = document.createElement('img');
        let carPicLoaded = false;

        let canvas;
        let canvastContext;

        let ball = {
            x: {
                pos: 75,
                speed: 5
            },
            y: {
                pos: 75,
                speed: 7
            }
        };

        let mouse = {
            x: 0,
            y: 0
        }

        let layout1 = [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
        ];

        let layout2 = [
            1, 1, 1, 1, 0, 1, 1, 1,
            1, 1, 0, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 0, 1,
            1, 1, 1, 1, 1, 1, 1, 1,
            1, 0, 0, 0, 0, 1, 0, 1
        ];

        let levelInfo = {
            level1: {
                track: {
                    width: 40,
                    height: 40,
                    gap: 2,
                    gutter: 0,
                    layout: [...layout1]
                }
            },
            level2: {
                track: {
                    width: 100,
                    height: 20,
                    gap: 2,
                    layout: layout2
                }
            }
        }

        let currentLevel = 'level1';
        let currentLevelInfo = levelInfo[currentLevel];

        let myInterval;

        window.onload = function () {
            console.group('Set Game Parameters');
            console.log('setting game parameters...');
            canvas = document.querySelector('#gameCanvas');
            canvastContext = canvas.getContext('2d');

            carPic.onload = function() {
                carPicLoaded = true;
            };

            carPic.src = 'img/player1car.png';

            console.log('game parameters set');
            console.groupEnd();
            init();
        };


        /*****************************
         * ADD YOUR CUSTOM CODE HERE *
        ******************************/
        function updateScreen() {
            drawObjects();
            objectCollisions();
            movingObjects();

            // TODO: START: mouse coords debug lines
            let trackCol = Math.floor(mouse.x / currentLevelInfo.track.width);
            let trackRow = Math.floor(mouse.y / currentLevelInfo.track.height);

            // let trackUnderMouse = getRowColLayoutIndex(trackCol, trackRow);
            // drawText(`${trackCol},${trackRow}:${trackUnderMouse}`, mouse.x, mouse.y, 'yellow');

            // if (trackCol >= 0 && trackCol < getColCount() &&
            //     trackRow >= 0 && trackRow < getRowCount()) {
            //     currentLevelInfo.track.layout[trackUnderMouse] = 0;
            // }
            // TODO: END: mouse coords debug lines
        }

        function drawObjects() {
            drawCanvas();
            drawBall();
            drawTracks();
        }

        function objectCollisions() {
            trackCollision();
        }

        function movingObjects() {
            // moveBall();
        }


        /********************************
         * START: BASE ENGINE FUNCTIONS *
        *********************************/

        function init() {
            console.log('Game build sucessful.');
            console.groupEnd();
            console.log('Game Menu.');

            addEventListeners();
            ballReset();
            handleInterval();
        }

        function handleInterval() {
            let framesPerSecond = 30;
            myInterval = setInterval(updateScreen, 1000 / framesPerSecond);
        }

        function addEventListeners() {
            canvas.addEventListener('mousemove', updateMousePos);
        }

        function updateMousePos(e) {
            let rect = canvas.getBoundingClientRect();
            let root = document.documentElement;

            mouse.x = e.clientX - rect.left - root.scrollLeft;
            mouse.y = e.clientY - rect.top - root.scrollTop;

            // TODO: temp mod for testing
            // ball.x.pos = mouse.x;
            // ball.y.pos = mouse.y;
            // ball.x.speed = 4;
            // ball.y.speed = -4;
        }

        // TODO: update to use layout/map vs canvas width
        function getRowCount() {
            return (currentLevelInfo.track.layout.length * currentLevelInfo.track.width) / canvas.width;
        }

        // TODO: update to use layout/map vs canvas width
        function getColCount() {
            return currentLevelInfo.track.layout.length / getRowCount();
        }

        function getRowColLayoutIndex(col, row) {
            return col + getColCount() * row;
        }

        function drawCanvas() {
            let canvasBackground = 'black';
            drawRect(0, 0, canvas.width, canvas.height, canvasBackground);
        }

        function drawRect(topLeftX, topLeftY, width, height, fillColor) {
            canvastContext.fillStyle = fillColor;
            canvastContext.fillRect(topLeftX, topLeftY, width, height);
        }

        function drawCircle(centerX, centerY, radius, fillColor) {
            canvastContext.fillStyle = fillColor;
            canvastContext.beginPath();
            canvastContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
            canvastContext.fill();
        }

        function drawText(text, xPos, yPos, color) {
            canvastContext.fillStyle = color;
            canvastContext.fillText(text, xPos, yPos);
        }

        /******************************
         * END: BASE ENGINE FUNCTIONS *
        *******************************/


        /*****************************
         * START: GAME SPECIFIC CODE *
        ******************************/

        function drawBall() {
            // let ballBackground = 'red';
            // drawCircle(ball.x.pos, ball.y.pos, 10, ballBackground);
            if (carPicLoaded) {
                canvastContext.drawImage(carPic, ball.x.pos - carPic.width / 2, ball.y.pos - carPic.height / 2);
            }
        }

        function gameOver() {
            clearInterval(myInterval);
            currentLevelInfo.track.layout = [...layout1];
            init();
        }

        function moveBall() {
            ball.x.pos += ball.x.speed;
            ball.y.pos += ball.y.speed;

            setBallBoundries();
        }

        function ballReset() {
            let trackBackground = 'red';
            let track = currentLevelInfo.track;

            for (let row = 0; row < getRowCount(); row++) {
                for (let col = 0; col < getColCount(); col++) {
                    let trackNumber = getRowColLayoutIndex(col, row);
                    if (track.layout[trackNumber] === 2) {
                        track.layout[trackNumber] = 0;
                        ball.x.pos = (col * track.width) + (track.width / 2);
                        ball.y.pos = (row * track.height) + (track.height / 2);
                    }
                }
            }
        }

        function setBallBoundries() {
            // set left
            if (ball.x.pos < 0 && ball.x.speed < 0.0) {
                ball.x.speed *= -1;
            }
            // set right
            if (ball.x.pos > canvas.width && ball.x.speed > 0.0) {
                ball.x.speed *= -1;
            }
            // set top
            if (ball.y.pos < 0 && ball.y.speed < 0.0) {
                ball.y.speed *= -1;
            }
            // set bottom
            if (ball.y.pos > canvas.height) {
                ballReset();
            }
        }

        function drawTracks() {
            let trackBackground = 'red';
            let track = currentLevelInfo.track;

            for (let row = 0; row < getRowCount(); row++) {
                for (let col = 0; col < getColCount(); col++) {
                    let trackNumber = getRowColLayoutIndex(col, row);
                    if (track.layout[trackNumber] === 1) {
                        drawRect(track.width * col, track.height * row, track.width - track.gap, track.height - track.gap, trackBackground);
                    }
                }
            }
        }

        function trackCollision() {
            let ballTrackCol = Math.floor(ball.x.pos / currentLevelInfo.track.width);
            let ballTrackRow = Math.floor(ball.y.pos / currentLevelInfo.track.height);
            let trackUnderBall = getRowColLayoutIndex(ballTrackCol, ballTrackRow);

            if (ballTrackCol >= 0 && ballTrackCol < getColCount() &&
                ballTrackRow >= 0 && ballTrackRow < getRowCount()) {
                if (currentLevelInfo.track.layout[trackUnderBall] === 1) {

                    let prevBallCol = ball.x.pos - ball.x.speed;
                    let prevBallRow = ball.y.pos - ball.y.speed;
                    let prevTrackCol = Math.floor(prevBallCol / currentLevelInfo.track.width);
                    let prevTrackRow = Math.floor(prevBallRow / currentLevelInfo.track.height);

                    let bothTestsFailed = true;
                    // check sides of track
                    if (prevTrackCol !== ballTrackCol) {
                        if (!isTrackAtColRow(prevTrackCol, ballTrackRow)) {
                            ball.x.speed *= -1;
                            bothTestsFailed = false;
                        }
                    }
                    // check bottom/top of track
                    if (prevTrackRow !== ballTrackRow) {
                        if (!isTrackAtColRow(ballTrackCol, prevTrackRow)) {
                            ball.y.speed *= -1;
                            bothTestsFailed = false;
                        }
                    }
                    // checks for armpit
                    if (bothTestsFailed) {
                        ball.x.speed *= -1;
                        ball.y.speed *= -1;
                    }
                }
            }
        }

        function isTrackAtColRow(col, row) {
            if (col >= 0 && col < getColCount() &&
                row >= 0 && row < getRowCount()) {
                let trackUnderCoord = getRowColLayoutIndex(col, row);
                return currentLevelInfo.track.layout[trackUnderCoord];
            } else {
                return false;
            }
        }

        /***************************
         * END: GAME SPECIFIC CODE *
        ****************************/

        console.log('compilation finished.');
        console.groupEnd();
    </script>

</body>

</html>